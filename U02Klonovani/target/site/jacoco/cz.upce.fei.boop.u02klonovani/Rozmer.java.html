<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Rozmer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">U02KlonovaniSkoda</a> &gt; <a href="index.source.html" class="el_package">cz.upce.fei.boop.u02klonovani</a> &gt; <span class="el_source">Rozmer.java</span></div><h1>Rozmer.java</h1><pre class="source lang-java linenums">package cz.upce.fei.boop.u02klonovani;



import java.util.Locale;
//&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;comment&quot;&gt;

/**
 * Třída {@code Rozmer} je určena pro vytváření objektů se třemi hodnotami,
 * které představují tři dimenze reálných trojrozměrných předmětů nebo prostorů.
 * &lt;p&gt;
 * Následující text obsahuje kromě popisu třídy {@code Rozmer} i trochu teorie
 * OOP. Úkolem studentů bude podle popisu v tomto dokumentačním komentáři a
 * testu třídy {@code RozmerTest} doplnit chybějící zdrojový kód třídy.
 * &lt;p&gt;
 * Třída {@code Rozmer} je ukázkou třídy podle které vytváří neměnné objekty
 * (Immutable object). U neměnných objektů po vytvoření již nemůže být
 * modifikován jejich stav a to až do konce jejich životů. Takový objekt může
 * být používán souběžně z více míst (tj. z různých vláken), aniž by hrozily
 * nekonzistence, tj. narušení stavu objektu a to tak, že z jednoho místa
 * změníme částečně stav a z druhého místa ho přepíšeme. Toto může nastávat ve
 * více vláknových aplikací. Použitím neměnných objektů vytváříme robustnější a
 * bezpečnější kód, aniž bychom k tomu potřebovali speciální nástroje.
 * &lt;p&gt;
 * Nejznámější neměnnou třídou v Javě je {@code String}, jejichž instance nelze
 * modifikovat. Například {@code String s = &quot;Hello &quot; + &quot;World&quot;} vytvoří tři
 * objekty {@code &quot;Hello&quot;, &quot;World&quot; a &quot;Hello World&quot;}. Proto při sestavování
 * složitějších textů použijeme instance třídy {@code StringBuilder}, které jsou
 * modifikovatelné (mutable).
 * &lt;p&gt;
 * Co taková neměnná třída jako je {@code Rozmer} může obsahovat?
 *
 * &lt;ol&gt;
 * &lt;li&gt;Veřejné konstanty.&lt;p&gt;
 * V našem případě to budou dvě konstanty, které budou definovat hranice rozsahu
 * povolených hodnot dimenze třídy {@code Rozmer}. Toho mohou uživatelé třídy
 * využít k vlastnímu omezení používaných hodnot a tím předcházet zbytečnému
 * vystavování výjimek.&lt;/p&gt;
 *
 * &lt;li&gt;Privátní konstanty.&lt;p&gt;
 * Slouží k různým účelům v implementaci třídy. Vetšinou jsou to neměnné (final)
 * proměnné s definovanou hodnotou, které většinou omezují používání číselných
 * literálů. Číselným literátům, které jsou použity v kódu se říká magická
 * čísla. Proč magická? To proto, že konkrétní číslo, např. 10, může na jednom
 * místě kódu představovat dimenzi a v jiném místě kódu počet sloupců
 * matice.&lt;/p&gt;
 *
 * &lt;li&gt;Proměnné třídy.&lt;p&gt;
 * V této třídě nejsou potřeba.&lt;p&gt;
 * U instančních tříd se používají výjimečně. Například, když chceme počítat
 * kolik jsme vytvořili instancí nebo, když chceme přidělit každé instanci
 * nějakou jednoznačnou hodnotu.&lt;p&gt;
 * U tříd, které tvoří pouze statické metody, tj. metody třídy, se samozřejmě
 * proměnné třídy běžně používají.&lt;/p&gt;
 *
 * &lt;li&gt;Instanční proměnné, neboli atributy.&lt;p&gt;
 * Instanční proměnné většinou deklarujeme na jednom místě před konstruktory a
 * metodami. Jejich obsah nebo jen některých z nich představuje stav objektu.
 * Instanční proměnné opatřujeme vždy modifikátorem {@code private}. Tím
 * skrýváme zásadním způsobem implementaci. Výhodu této zásady si ukážeme právě
 * na této třídě.&lt;p&gt;
 * V našem případě budou všechny tři instanční proměnné typu {@code long} a
 * budou představovat hodnoty v centimetrech. Zatímco přístupové metody k těmto
 * instančním proměnným budou vracet hodnoty v metrech a typově {@code double}.
 * To samé, ale obráceně, bude platit pro parametry konstruktoru, které budou v
 * metrech a v typu {@code double}. Proto musí docházet jak v konstruktoru, tak
 * v přístupových metodách k převodu hodnot.&lt;p&gt;
 * Protože tuto třídu navrhujeme pro vytváření neměnných objektů, jsou hodnoty
 * instančních proměnných definovány až v konstruktoru podle jeho parametrů a
 * poté je nelze změnit. Neměnnost instančních proměnných se zajistí
 * modifikátorem {@code final}.
 * &lt;/p&gt;
 *
 * &lt;li&gt;Konstruktory.&lt;p&gt;
 * Konstruktor u neměnných objektů musí inicializovat všechny instanční
 * proměnné. V našem případě ještě konstruktor provede přepočet vstupních
 * parametrů na vnitřní rozměr tj. z metrů na centimetry.&lt;/p&gt;
 *
 * &lt;li&gt;Přístupové metody&lt;p&gt;
 * Tyto metody přistupují k soukromým instančním proměnným a převádějí jejich
 * hodnoty z vnitřního typu na výstupní typ. V našem případě přepočítávají
 * hodnotu z centimetrů na metry a mění datový typ z {@code long} na
 * {@code double}
 * .&lt;/p&gt;
 *
 * &lt;li&gt;Sestavení informace o stavu objektu&lt;p&gt;
 * Někdy je zapotřebí ziskat popis toho co je to za objekt a v jakém stavu se
 * nachází. Proto v Javě už ve třídě {@code Object} je deklarována metoda
 * {@code toString()} a tím pádem tuto metodu má kterákoliv další třída. Tato
 * metoda sestavuje textový řetězec, kde je uvedeno pouze název třídy z které
 * byl objekt vytvořen a referenci, což je 32 bitové číslo, které jednoznačně
 * identifikuje daný objekt. Tuto metodu mohou ostatní potomci překrýt svojí
 * verzí. Tyto nové verze metod {@code toString()} mohou přistupovat ke členům
 * své třídy (atributům a metodám) a sestavovat z nich svůj popis stavu objektu.
 * Stav předka lze sestavit a přidat k popisu stavu potomka pomocí {@code super}
 * a volání metody {@code toString()}
 * &lt;/p&gt;
 *
 * &lt;li&gt;Metody {@code equals()} a {@code hashCode()}
 * &lt;p&gt;
 * Tyto dvě metody jsou též jako metoda {@code toString()} deklarovány ve třídě
 * {@code Object}. Pokud ve své třídě překryjeme jednu z nich, tak musíme
 * překrýt i druhou. To vyžaduje kontrakt.&lt;p&gt;
 * K čemu se používají?
 * &lt;p&gt;
 * Budeme se věnovat pouze metodě {@code equals(Object obj)}, která slouží k
 * porovnání dvou objektů.&lt;p&gt;
 * Pokud tuto metodu nepřekryjeme, tak dojde k porovnání referencí objektů.
 * Tzn., že se porovnají číselné hodnoty referencí. Co to znamená a kdy může
 * nastat shoda? Shoda může nastat jen tehdy a pouze tehdy, když {@code this} a
 * parameter metody {@code obj} obsahují stejná čísla, tedy reference. Když tomu
 * tak je, tak jsme zjitili, že se jedná o ten samý objekt.&lt;p&gt;
 * Pokud ovšem v naší třídě metodu {@code equals()} překryjeme, tak můžeme
 * porovnat dva objekty odkazované {@code this} a parametrem {@code obj} podle
 * hodnot v jejich atributech.
 *
 *
 * &lt;li&gt;Ostatní veřejné metody
 *
 * &lt;li&gt;Privátní metody
 *
 * &lt;/ol&gt;
 *
 * @author karel@simerda.cz
 */
//&lt;/editor-fold&gt;
public class Rozmer
{

//&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Veřejné konstanty&quot;&gt;
    /**
     * Maximální hodnota dílčího rozměru v metrech
     */
    public static final double DIMENZE_MAX = 100.0;
    /**
     * Minimální hodnota dílčího rozměru v metrech
     */
    public static final double DIMENZE_MIN = .1;
//&lt;/editor-fold&gt;

//&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Privátní konstanty &quot;&gt;
    //Konstanta na přepočítání metrů na centimetry
    private static final double TO_CM = 100;
//&lt;/editor-fold&gt;

//&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Instanční proměnné/Atributy&quot;&gt;
    // Stav objektu-u neměných objektu použít final
    /**
     * Délka rozměru jako celé číslo v centimetrech
     */
      private final long delka;
    /**
     * Šířka rozměru jako celé číslo v centimetrech
     */
      private final long sirka;
    /**
     * Výška rozměru jako celé číslo v centimetrech
     */
      private final long vyska;
//&lt;/editor-fold&gt;

//&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Konstruktory&quot;&gt;
    /**
     * Konstruktor třídy zajistí definici (inicializaci) hodnot privátních
     * instančních proměnných
     *
     * @param delka rozměr délka v m
     * @param sirka rozměr šířka v m
     * @param vyska rozměr výška v m
     *
     * @throws MojeException se vystaví, když alespoň hodnota jednoho vstupního
     * parametruje mimo povolený rozsah
     */
<span class="fc" id="L174">    public Rozmer(final double delka, final double sirka, final double vyska) {</span>
<span class="fc bfc" id="L175" title="All 6 branches covered.">       if(Rozmer.check(delka) &amp;&amp; Rozmer.check(sirka) &amp;&amp; Rozmer.check(vyska))</span>
       {
<span class="fc" id="L177">           this.delka = Math.round(delka * Rozmer.TO_CM);</span>
<span class="fc" id="L178">           this.sirka = Math.round(sirka * Rozmer.TO_CM);</span>
<span class="fc" id="L179">           this.vyska = Math.round(vyska * Rozmer.TO_CM);</span>
       }
       else
       {
<span class="fc" id="L183">           throw new MojeException(&quot;Rozmer je mimo povoleny rozsah.&quot;);</span>
       }
       
<span class="fc" id="L186">    }</span>
//&lt;/editor-fold&gt;

//&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Přístupové metody ke stavu&quot;&gt;
    /**
     * @return hodnota délky rozměru v m
     */
    public double getDelka()
    {
<span class="fc" id="L195">        return this.delka/Rozmer.TO_CM;</span>
    }

    /**
     * @return hodnota šířky rozměru v m
     */
    public double getSirka()
    {
<span class="fc" id="L203">        return this.sirka/Rozmer.TO_CM;</span>
    }

    /**
     * @return hodnota výšky rozměru v m
     */
    public double getVyska()
    {
<span class="fc" id="L211">        return this.vyska/Rozmer.TO_CM;</span>
    }
//&lt;/editor-fold&gt;

//&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Sestavení informace o stavu - toString&quot;&gt;
    /**
     * Nápověda:
     * format(Locale.ENGLISH, &quot;Rozmer{delka=%5.2f,sirka=%5.2f,vyska=%5.2f}&quot;, 
     * 
     * @return 
     */
    @Override
    public String toString()
    {
<span class="fc" id="L225">        return String.format(Locale.ENGLISH,</span>
                &quot;Rozmer{delka=%5.2f,sirka=%5.2f,vyska=%5.2f}&quot;,
<span class="fc" id="L227">                this.getDelka(),</span>
<span class="fc" id="L228">                this.getSirka(),</span>
<span class="fc" id="L229">                this.getVyska());</span>
    }
//&lt;/editor-fold&gt;

//&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Metody equals a hashCode&quot;&gt;

    @Override
    public int hashCode()
    {
<span class="fc" id="L238">        int hash = 5;</span>
<span class="fc" id="L239">        hash = 89 * hash + (int) (this.delka ^ (this.delka &gt;&gt;&gt; 32));</span>
<span class="fc" id="L240">        hash = 89 * hash + (int) (this.sirka ^ (this.sirka &gt;&gt;&gt; 32));</span>
<span class="fc" id="L241">        hash = 89 * hash + (int) (this.vyska ^ (this.vyska &gt;&gt;&gt; 32));</span>
<span class="fc" id="L242">        return hash;</span>
    }
   

    @Override
    public boolean equals(Object obj)
    {
<span class="fc bfc" id="L249" title="All 2 branches covered.">        if (this == obj) {</span>
<span class="fc" id="L250">            return true;</span>
        }
<span class="fc bfc" id="L252" title="All 2 branches covered.">        if (obj == null) {</span>
<span class="fc" id="L253">            return false;</span>
        }
<span class="fc bfc" id="L255" title="All 2 branches covered.">        if (getClass() != obj.getClass()) {</span>
<span class="fc" id="L256">            return false;</span>
        }
<span class="fc" id="L258">        final Rozmer other = (Rozmer) obj;</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">        if (this.delka != other.delka) {</span>
<span class="fc" id="L260">            return false;</span>
        }
<span class="fc bfc" id="L262" title="All 2 branches covered.">        if (this.sirka != other.sirka) {</span>
<span class="fc" id="L263">            return false;</span>
        }
<span class="fc bfc" id="L265" title="All 2 branches covered.">        if (this.vyska != other.vyska) {</span>
<span class="fc" id="L266">            return false;</span>
        }
<span class="fc" id="L268">        return true;</span>
    }
   
//&lt;/editor-fold&gt;

//&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Ostatní veřejné metody&quot;&gt;
    /**
     * @param dimenze hodnota dílčího rozměru ke kontrole v metrech
     * @return vraci true, kdyz je dimenze v povoleném rozsahu
     */
    public static boolean kontrolaDimenze(double dimenze)
    {
<span class="fc" id="L280">        return Rozmer.check(dimenze);</span>
    }
//&lt;/editor-fold&gt;

//&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Privátní metody&quot;&gt;
    private static boolean check(double dimenze)
    {
<span class="fc bfc" id="L287" title="All 4 branches covered.">        return dimenze &gt;= Rozmer.DIMENZE_MIN &amp;&amp; dimenze &lt;= Rozmer.DIMENZE_MAX;</span>
    }
//&lt;/editor-fold&gt;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>